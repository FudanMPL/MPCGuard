import torch.nn.functional as F
import argparse
import yaml
import traceback

import functionality

import detect_leakage_for_output
import detect_leakage_for_input
from tools_and_global_parameters import *
import os
import time

from load_data import  *

import torch
import random
import numpy as np

seed = 66
random.seed(seed)
np.random.seed(seed)
torch.manual_seed(seed)
torch.cuda.manual_seed(seed)
torch.cuda.manual_seed_all(seed) 
torch.backends.cudnn.deterministic = True
torch.backends.cudnn.benchmark = False


def generate_secret_pair():
    # Here, we use five secret pairs which are generated by bit flip and value flip, more secret pairs can be added
    secret_paires = []
    secret_paires.append((1049088, -2**63))
    secret_paires.append((-5374770517643919356, 0))
    secret_paires.append((-1049088, 2**63-1))
    secret_paires.append((123123123, ~123123123))
    secret_paires.append((-2**63, 2**63-1))                      
    return secret_paires


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="test a mpc protocol")

    parser.add_argument(
        "--config-file",
        metavar="FILE",
        type=str,
        default="mpcguard_config.json",
        help="configuration file",
    )
    args = parser.parse_args()
    load_config(args.config_file)


    os.makedirs(my_config['real_view_data_dir'], exist_ok=True)

    file_path = my_config['bug_file']
    parent_dir = os.path.dirname(file_path)
    os.makedirs(parent_dir, exist_ok=True)

 
    logger.info("================   test program: {} with {}  ================".format(my_config['real_program'], args.config_file))
    timer['model_train_and_test'] = 0
    timer['run_real_protocol'] = 0
    timer['vul_location'] = 0
    timer['vul_verify'] = 0
    total_time = 0
    start_time = time.time()
    try:
        for secret1, secret2 in generate_secret_pair():
            if not exist_real_review_data_of_secret(secret1) or my_config['run_mode'] == 'all':
                run_real_protocol(secret1)
            if not exist_real_review_data_of_secret(secret2) or my_config['run_mode'] == 'all':
                run_real_protocol(secret2)
      
            run_ideal_protocol(secret1)
            run_ideal_protocol(secret2)
            if detect_leakage_for_input.detect_leakage(secret1, secret2):
                break
            if detect_leakage_for_output.detect_leakage(secret1):
                break
            if detect_leakage_for_output.detect_leakage(secret2):
                break

    except Exception as e:
        # print stack trace of e
        traceback.print_exc()
        logger.exception("An error occurred")

    end_time = time.time()
    total_time = end_time - start_time
    logger.info("Total time: {}".format(total_time))
    logger.info("Protocol Execution time: {}".format(timer['run_real_protocol']))
    logger.info("Vulnerability Verification time: {}".format(timer['vul_verify']))
    logger.info("Vulnerability Location time: {}".format(timer['vul_location']))
    other_time = total_time - timer['vul_verify'] - timer['run_real_protocol'] - timer['vul_location']
    logger.info("Other time: {}".format(other_time))
    logger.info("Additionally, Model Train and Test time: {}".format(timer['model_train_and_test']))
